module Daml.Trading.Cash.CashRedemption where 

-- import Daml.Finance.Interface.Holding.Account qualified as Account ( Debit(..), R)
import Daml.Finance.Interface.Holding.Base qualified as Holding (I)
import Daml.Trading.Cash.CashTransfer qualified as CashTransfer
import Daml.Trading.Cash.CreateCashAccount qualified as CreateCashAccount
import Daml.Finance.Interface.Holding.Factory.Account qualified as Account (F)
import Daml.Finance.Interface.Holding.Factory.Holding qualified as Holding (F)
import Daml.Finance.Interface.Holding.Fungible qualified as Fungible (I)
import Daml.Finance.Interface.Types.Common (InstrumentKey(..))
import Daml.Trading.Scripts.CashSetup qualified as CashSetup (instrumentData) 
import Daml.Finance.Interface.Holding.Fungible (ArchiveFungible(ArchiveFungible))
import Daml.Finance.Interface.Holding.Fungible qualified as Fungible (Split(..), SplitResult(..))
import Daml.Finance.Interface.Holding.Util (getAmount)

template SplitRequest
    with 
        currentOwner: Party
        amount: Decimal
    where
        signatory currentOwner
        nonconsuming choice Split : [ContractId Fungible.I]
            with
                holdingCid : ContractId Holding.I
            controller currentOwner
            do
            -- Sanity checks
                holding <- fetch holdingCid
                assertMsg "Balance insufficient" (amount <= getAmount holding)
                let 
                    fungibleCid : ContractId Fungible.I = coerceContractId holdingCid
                Fungible.SplitResult{splitCids,rest} <- exercise fungibleCid Fungible.Split with amounts = [amount]
                pure (splitCids)

template WithdrawalRequest
    with
        operator : Party
        customer : Party
        holdingCid : ContractId Holding.I
        amount : Decimal
    where
        signatory customer
        observer operator

        ensure amount > 0.0

        choice Accept : ()
            with
                accountFactoryCid: ContractId Account.F 
                holdingFactoryCid: ContractId Holding.F 
            controller operator
            do
                let
                    (instrumentId, instrumentVersion) = CashSetup.instrumentData
                    cashInstrument = InstrumentKey with issuer = operator; depository = operator; id = instrumentId; version = instrumentVersion

                adminRequestCid <- create CreateCashAccount.Request
                    with
                        owner = operator
                        custodian = operator
                
                adminBurnAccount <- exercise adminRequestCid CreateCashAccount.Accept
                    with
                        label = "Admin@Admin"
                        description = "Account of AdminBurn"
                        accountFactoryCid = accountFactoryCid
                        holdingFactoryCid = holdingFactoryCid
                        observers = [customer]
                
                -- TODO: Split funding before request
                splitRequest <- create SplitRequest
                    with
                        currentOwner = customer
                        amount = amount

                [burnCid] <- exercise splitRequest Split
                    with 
                        holdingCid = holdingCid

                transferRequest <- create CashTransfer.Request
                    with
                        receiverAccount = adminBurnAccount
                        instrument = cashInstrument
                        amount = amount
                        currentOwner = customer

                let
                    newburnCid : ContractId Holding.I = coerceContractId burnCid

                adminBurnWallet <- exercise transferRequest CashTransfer.Accept
                    with
                        holdingCid = newburnCid
                exercise (coerceContractId adminBurnWallet : ContractId Fungible.I) ArchiveFungible
                pure()

        choice Decline : ()
            controller operator
            do pure ()

        choice Cancel : ()
            controller customer
            do pure ()