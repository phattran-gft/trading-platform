module Daml.Trading.Cash.CashTransfer where 

import DA.Assert ((===))
import Daml.Finance.Interface.Holding.Base qualified as Holding (I)
import Daml.Finance.Interface.Holding.Transferable qualified as Transferable (I, Transfer(..))
import Daml.Finance.Interface.Holding.Util (getAmount, getInstrument)
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as Instrument (K)
import Daml.Finance.Interface.Types.Common (AccountKey(..))
import Daml.Trading.Account.Account qualified as CreateAccount


template Request
  with
    custodian : Party
    owner : Party
    receiverAccount : AccountKey
    instrument : Instrument.K
    amount : Decimal
    
  where
    signatory receiverAccount.owner
    observer owner

    ensure amount > 0.0

    choice Accept : (ContractId Holding.I, Optional (ContractId Holding.I))
      with
        holdingCid : ContractId Holding.I
      controller owner
      do
        holding <- fetch holdingCid
        getInstrument holding === instrument
        assertMsg "Balance insufficient" (amount <= getAmount holding)
        
        (accountCid,_) <- fetchByKey @CreateAccount.Account (custodian, owner)
        (transferCid,remainingOpt) <- exercise accountCid CreateAccount.Split
          with
            holdingCid = holdingCid
            amount = amount
        let
          transferableCid : ContractId Transferable.I = coerceContractId transferCid
        newTransferableCid <- exercise transferableCid Transferable.Transfer
          with
            newOwnerAccount = receiverAccount
        let
          lastTransferableCid : ContractId Holding.I = coerceContractId newTransferableCid
        pure (lastTransferableCid,remainingOpt)

    choice Decline : ()
      controller owner
      do pure ()

    choice Withdraw : ()
      controller receiverAccount.owner
      do pure ()