module Daml.Trading.Account.Account where 

import DA.Optional (whenSome, isNone)
import DA.Set qualified as S (fromList, singleton)
import Daml.Finance.Interface.Holding.Factory.Account qualified as Account (Create(..), F, Remove(..))
import Daml.Finance.Interface.Holding.Factory.Holding qualified as Holding (F)
import Daml.Finance.Interface.Instrument.Base.Factory qualified as Instrument (F)
import Daml.Finance.Interface.Types.Common (AccountKey(..), Id(..))
import Daml.Trading.Reward.Badge qualified as Badge
import DA.Map qualified as M
import Daml.Finance.Interface.Holding.Util (getAmount)
import Daml.Finance.Interface.Holding.Base qualified as Holding (I)
import Daml.Finance.Interface.Holding.Fungible qualified as Fungible (I, Split(..), SplitResult(..),Merge(..))
import DA.List (head,tail)

cashLabel = "Cash"
nftLabel = "Nft"

-- to fetch the account factory for subsequent account creation
template AccountFactoryReference 
  with 
    provider: Party 
    accountFactoryCid: ContractId Account.F 
  where 
    signatory provider 
    key provider: Party 
    maintainer key 

template HoldingFactoryReference 
  with 
    provider: Party 
    holdingType: Text 
    holdingFactoryCid: ContractId Holding.F 
  where 
    signatory provider 
    key (provider, holdingType): (Party, Text) 
    maintainer key._1 

template InstrumentFactoryReference 
  with 
    provider: Party 
    instrumentType: Text 
    instrumentFactoryCid: ContractId Instrument.F 
  where 
    signatory provider 
    key (provider, instrumentType): (Party, Text) 
    maintainer key._1 

template Request 
  with 
    custodian: Party
    owner: Party 
    accountType: AccountType 
    username: Text 
    realName: Text 
    passportNumber: Text 
    nationalId: Text 
    address: Text 
  where 
    signatory owner 
    observer custodian 

    choice Request_Accept: ContractId Account 
      controller custodian 
      do
        create Account 
          with 
            custodian 
            owner 
            accountType 
            username 
            realName 
            passportNumber 
            nationalId 
            address 
            optCashAccount = None 
            optNftAccount = None 
            rewardPoints = 0 
            badges = []

    choice Request_Decline : ()
      controller custodian
      do pure ()

    choice Request_Withdraw : ()
      controller owner
      do pure ()

template Account 
  with 
    custodian: Party 
    owner: Party 
    accountType: AccountType 
    username: Text 
    realName: Text 
    passportNumber: Text 
    nationalId: Text 
    address: Text 
    optCashAccount: Optional (ContractId Account.F, ContractId Holding.F, AccountKey) 
    optNftAccount: Optional (ContractId Account.F, ContractId Holding.F, ContractId Instrument.F, AccountKey) 
    rewardPoints : Int
    badges : [ContractId Badge.Badge]
  where 
    signatory custodian, owner 
    key (custodian, owner): (Party, Party)
    maintainer key._1 

    choice Update_Permission: ContractId Account 
      with 
        newAccountType: AccountType 
      controller custodian 
      do 
        assertMsg ("New account type should be different from current one") (accountType /= newAccountType)
        create this with accountType = newAccountType 
    
    choice Create_Cash_Account: ContractId Account 
      with 
        description: Text 
        accountFactoryCid: ContractId Account.F 
        holdingFactoryCid: ContractId Holding.F 
        observers: [Party] 
      controller custodian 
      do 
        assertMsg ("User already has a cash account") (isNone optCashAccount) 

        let
          observersSet = S.fromList $ map S.singleton observers
          accountKey = AccountKey with custodian = custodian, owner = owner, id = Id cashLabel 

        exercise accountFactoryCid Account.Create with
          account = accountKey
          description = description
          holdingFactoryCid = holdingFactoryCid
          observers = M.fromList [("AccountObservers", observersSet)]
        
        create this with optCashAccount = Some (accountFactoryCid, holdingFactoryCid, accountKey)
    
    choice Create_Nft_Account: ContractId Account 
      with 
        description: Text 
        accountFactoryCid: ContractId Account.F 
        holdingFactoryCid: ContractId Holding.F 
        instrumentFactoryCid: ContractId Instrument.F
        observers: [Party] 
      controller custodian 
      do 
        assertMsg ("User already has a nft account") (isNone optNftAccount) 

        let
          observersSet = S.fromList $ map S.singleton observers
          accountKey = AccountKey with custodian = custodian, owner = owner, id = Id nftLabel 

        exercise accountFactoryCid Account.Create with
          account = accountKey
          description = description
          holdingFactoryCid = holdingFactoryCid
          observers = M.fromList [("AccountObservers", observersSet)]
        
        create this with optNftAccount = Some (accountFactoryCid, holdingFactoryCid, instrumentFactoryCid, accountKey)
    
    choice Redeem_Badge: ContractId Account
      with  
        redeem_badge: Badge.BadgeType
      controller owner
      do
        contractBadgeList <- forA badges \badge -> fetch badge
        let
          badgeUserResult = filter (\contractBadge -> contractBadge.badge == redeem_badge) contractBadgeList
          currentRewardPoints = rewardPoints
        assertMsg "Trader already owns this badge!" (null badgeUserResult)
        case (redeem_badge) of
          Badge.Novice_Trader -> do 
            assertMsg "Not enough points" (currentRewardPoints >= 20)
            newBadge <- create Badge.Badge with 
              admin = custodian
              owner = owner
              badge = redeem_badge
            accountWithBadgeCid <- create Account with 
              rewardPoints = currentRewardPoints - 20
              badges = newBadge :: badges
              ..
            pure(accountWithBadgeCid)
          Badge.Pro_Trader -> do
            assertMsg "Not enough points" (currentRewardPoints >= 100)
            newBadge <- create Badge.Badge with 
              admin = custodian
              owner = owner
              badge = redeem_badge
            accountWithBadgeCid <- create Account with 
              rewardPoints = currentRewardPoints - 100
              badges = newBadge :: badges
              ..
            pure(accountWithBadgeCid)
          Badge.Hall_of_Fame_Trader -> do
            assertMsg "Not enough points" (currentRewardPoints >= 1000)
            newBadge <- create Badge.Badge with 
              admin = custodian
              owner = owner
              badge = redeem_badge
            accountWithBadgeCid <- create Account with 
              rewardPoints = currentRewardPoints - 1000
              badges = newBadge :: badges
              ..
            pure(accountWithBadgeCid)
           
      
    choice Close_Account: () 
      controller owner 
      do 
        -- remove holdings?
        -- remove all associated accounts
        whenSome optCashAccount \(cashAccountFactoryCid, _, cashAccountKey) -> do 
          exercise cashAccountFactoryCid Account.Remove with account = cashAccountKey 
        whenSome optNftAccount \(nftAccountFactoryCid, _, _, nftAccountKey) -> do 
          exercise nftAccountFactoryCid Account.Remove with account = nftAccountKey 
        pure ()

    nonconsuming choice Split : (ContractId Holding.I, Optional (ContractId Holding.I))
      with
        holdingCid : ContractId Holding.I
        amount: Decimal
      controller owner
      do
        holding <- fetch holdingCid
        assertMsg "Balance insufficient" (amount <= getAmount holding)
        let
          fungibleCid : ContractId Fungible.I = coerceContractId holdingCid
        Fungible.SplitResult{splitCids,rest} <- exercise fungibleCid Fungible.Split with amounts = [amount]
        let
          splitholdingCid = coerceContractId (head (splitCids))
          restholdingCid =  coerceContractId <$> rest
        pure (splitholdingCid, restholdingCid)

    nonconsuming choice Merge : ContractId Holding.I
      with
        holdingCids : [ContractId Holding.I]
      controller owner
      do
        let
          fungibleCids : [ContractId Fungible.I] = map (\hCid -> coerceContractId hCid) holdingCids
        mergeFungible <- exercise (head(fungibleCids)) Fungible.Merge with fungibleCids = tail(fungibleCids)
        let
          mergeholding = coerceContractId mergeFungible
        pure (mergeholding)


-- we use custodian Party as admin for simplicity
data AccountType 
  = Admin 
  | Retail 
  | Pro 
  deriving (Eq, Show)
    