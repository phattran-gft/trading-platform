module Daml.Trading.Account.Account where 

import DA.Optional (whenSome, isNone)
import DA.Set qualified as S (fromList, singleton)
import Daml.Finance.Interface.Holding.Factory.Account qualified as Account (Create(..), F, Remove(..))
import Daml.Finance.Interface.Holding.Factory.Holding qualified as Holding (F)
import Daml.Finance.Interface.Types.Common (AccountKey(..), Id(..))
import Daml.Trading.Reward.Badge qualified as Badge
import DA.Map qualified as M

cashLabel = "Cash"
nftLabel = "Nft"

-- to fetch the account factory for subsequent account creation
template AccountFactoryReference 
  with 
    provider: Party 
    accountFactoryCid: ContractId Account.F 
  where 
    signatory provider 
    key provider: Party 
    maintainer key 

-- is this needed?
template HoldingFactoryReference 
  with 
    provider: Party 
    holdingType: Text 
    holdingFactoryCid: ContractId Holding.F 
  where 
    signatory provider 
    key (provider, holdingType): (Party, Text) 
    maintainer key._1 

template Request 
  with 
    custodian: Party
    owner: Party 
    accountType: AccountType 
    username: Text 
    realName: Text 
    passportNumber: Text 
    nationalId: Text 
    address: Text 
  where 
    signatory owner 
    observer custodian 

    choice Request_Accept: ContractId Account 
      controller custodian 
      do
        create Account 
          with 
            custodian 
            owner 
            accountType 
            username 
            realName 
            passportNumber 
            nationalId 
            address 
            optCashAccount = None 
            optNftAccount = None 
            rewardPoints = 0 
            badges = []

    choice Request_Decline : ()
      controller custodian
      do pure ()

    choice Request_Withdraw : ()
      controller owner
      do pure ()

template Account 
  with 
    custodian: Party 
    owner: Party 
    accountType: AccountType 
    username: Text 
    realName: Text 
    passportNumber: Text 
    nationalId: Text 
    address: Text 
    optCashAccount: Optional (ContractId Account.F, ContractId Holding.F, AccountKey) 
    optNftAccount: Optional (ContractId Account.F, ContractId Holding.F, AccountKey) 
    rewardPoints : Int
    badges : [ContractId Badge.Badge]
  where 
    signatory custodian 
    observer owner
    key (custodian, owner): (Party, Party)
    maintainer key._1 

    choice Update_Permission: ContractId Account 
      with 
        newAccountType: AccountType 
      controller custodian 
      do 
        assertMsg ("New account type should be different from current one") (accountType /= newAccountType)
        create this with accountType = newAccountType 
    
    choice Create_Cash_Account: ContractId Account 
      with 
        description: Text 
        accountFactoryCid: ContractId Account.F 
        holdingFactoryCid: ContractId Holding.F 
        observers: [Party] 
      controller custodian 
      do 
        assertMsg ("User already has a cash account") (isNone optCashAccount) 

        let
          observersSet = S.fromList $ map S.singleton observers
          accountKey = AccountKey with custodian = custodian, owner = owner, id = Id cashLabel 

        exercise accountFactoryCid Account.Create with
          account = accountKey
          description = description
          holdingFactoryCid = holdingFactoryCid
          observers = M.fromList [("AccountObservers", observersSet)]
        
        create this with optCashAccount = Some (accountFactoryCid, holdingFactoryCid, accountKey)
    
    choice Create_Nft_Account: ContractId Account 
      with 
        description: Text 
        accountFactoryCid: ContractId Account.F 
        holdingFactoryCid: ContractId Holding.F 
        observers: [Party] 
      controller custodian 
      do 
        assertMsg ("User already has a nft account") (isNone optNftAccount) 

        let
          observersSet = S.fromList $ map S.singleton observers
          accountKey = AccountKey with custodian = custodian, owner = owner, id = Id nftLabel 

        exercise accountFactoryCid Account.Create with
          account = accountKey
          description = description
          holdingFactoryCid = holdingFactoryCid
          observers = M.fromList [("AccountObservers", observersSet)]
        
        create this with optNftAccount = Some (accountFactoryCid, holdingFactoryCid, accountKey)
    
    choice Redeem_Badge: ContractId Account
      with  
        redeem_badge: Badge.BadgeType
      controller owner
      do
        contractBadgeList <- forA badges \badge -> fetch badge
        let
          badgeResult = filter (\contractBadge -> contractBadge.badge == redeem_badge) contractBadgeList
          currentRewardPoints = rewardPoints
        if currentRewardPoints >= 20 && null badgeResult && redeem_badge == Badge.Novice_Trader then do
          newBadge <- create Badge.Badge with 
            admin = custodian
            owner = owner
            badge = redeem_badge
          accountWithBadgeCid <- create Account with 
            rewardPoints = currentRewardPoints - 20
            badges = newBadge :: badges
            ..
          pure(accountWithBadgeCid)
        else do
          if currentRewardPoints >= 100 && null badgeResult && redeem_badge == Badge.Pro_Trader then do
            newBadge <- create Badge.Badge with 
              admin = custodian
              owner = owner
              badge = redeem_badge
            accountWithBadgeCid <- create Account with 
              rewardPoints = currentRewardPoints - 100
              badges = newBadge :: badges
              ..
            pure(accountWithBadgeCid)
          else do 
            if currentRewardPoints >= 1000 && null badgeResult && redeem_badge == Badge.Hall_of_Fame_Trader then do
              newBadge <- create Badge.Badge with 
                admin = custodian
                owner = owner
                badge = redeem_badge
              accountWithBadgeCid <- create Account with 
                rewardPoints = currentRewardPoints - 1000
                badges = newBadge :: badges
                ..
              pure(accountWithBadgeCid)
            else do 
              (accountCid, account) <- fetchByKey @Account (custodian, owner)
              pure(accountCid)

    choice Close_Account: () 
      controller owner 
      do 
        -- remove holdings?
        -- remove all associated accounts
        whenSome optCashAccount \(cashAccountFactoryCid, _, cashAccountKey) -> do 
          exercise cashAccountFactoryCid Account.Remove with account = cashAccountKey 
        whenSome optNftAccount \(nftAccountFactoryCid, _, nftAccountKey) -> do 
          exercise nftAccountFactoryCid Account.Remove with account = nftAccountKey 
        pure ()

-- we use custodian Party as admin for simplicity
data AccountType 
  = Admin 
  | Retail 
  | Pro 
  deriving (Eq, Show)
    