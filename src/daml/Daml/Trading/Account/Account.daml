module Daml.Trading.Account.Account where 

import DA.Optional (isNone)
import DA.Map qualified as M (fromList)
import DA.Set qualified as S (fromList, singleton)
import DA.List (head)
import Daml.Finance.Interface.Holding.Factory.Account qualified as Account (Create(..), F)
import Daml.Finance.Interface.Holding.Factory.Holding qualified as Holding (F)
import Daml.Finance.Interface.Instrument.Base.Factory qualified as Instrument (F)
import Daml.Finance.Interface.Types.Common (AccountKey(..), Id(..))
import Daml.Finance.Interface.Holding.Util (getAmount)
import Daml.Finance.Interface.Holding.Base qualified as Holding (I)
import Daml.Finance.Interface.Holding.Fungible qualified as Fungible (I, Split(..), SplitResult(..))

cashLabel = "Cash"
nftLabel = "Nft"

-- to fetch the account factory for subsequent account creation
template AccountFactoryReference 
  with 
    provider: Party 
    accountFactoryCid: ContractId Account.F 
  where 
    signatory provider 
    key provider: Party 
    maintainer key 

template HoldingFactoryReference 
  with 
    provider: Party 
    holdingType: Text 
    holdingFactoryCid: ContractId Holding.F 
  where 
    signatory provider 
    key (provider, holdingType): (Party, Text) 
    maintainer key._1 

template InstrumentFactoryReference 
  with 
    provider: Party 
    instrumentType: Text 
    instrumentFactoryCid: ContractId Instrument.F 
  where 
    signatory provider 
    key (provider, instrumentType): (Party, Text) 
    maintainer key._1 

template Account 
  with 
    custodian: Party 
    owner: Party 
    accountType: AccountType 
    username: Text 
    realName: Text 
    passportNumber: Text 
    nationalId: Text 
    address: Text 
    optCashAccount: Optional (ContractId Account.F, ContractId Holding.F, AccountKey) 
    optNftAccount: Optional (ContractId Account.F, ContractId Holding.F, ContractId Instrument.F, AccountKey) 
  where 
    signatory custodian, owner 
    key (custodian, owner): (Party, Party)
    maintainer key._1 

    choice Update_Permission: ContractId Account 
      with 
        newAccountType: AccountType 
      controller custodian 
      do 
        assertMsg ("New account type should be different from current one") (accountType /= newAccountType)
        create this with accountType = newAccountType 
    
    choice Create_Cash_Account: ContractId Account 
      with 
        description: Text 
        accountFactoryCid: ContractId Account.F 
        holdingFactoryCid: ContractId Holding.F 
        observers: [Party] 
      controller custodian 
      do 
        assertMsg ("User already has a cash account") (isNone optCashAccount) 

        let
          observersSet = S.fromList $ map S.singleton observers
          accountKey = AccountKey with custodian = custodian, owner = owner, id = Id cashLabel 

        exercise accountFactoryCid Account.Create with
          account = accountKey
          description = description
          holdingFactoryCid = holdingFactoryCid
          observers = M.fromList [("AccountObservers", observersSet)]
        
        create this with optCashAccount = Some (accountFactoryCid, holdingFactoryCid, accountKey)
    
    choice Create_Nft_Account: ContractId Account 
      with 
        description: Text 
        accountFactoryCid: ContractId Account.F 
        holdingFactoryCid: ContractId Holding.F 
        instrumentFactoryCid: ContractId Instrument.F
        observers: [Party] 
      controller custodian 
      do 
        assertMsg ("User already has a nft account") (isNone optNftAccount) 

        let
          observersSet = S.fromList $ map S.singleton observers
          accountKey = AccountKey with custodian = custodian, owner = owner, id = Id nftLabel 

        exercise accountFactoryCid Account.Create with
          account = accountKey
          description = description
          holdingFactoryCid = holdingFactoryCid
          observers = M.fromList [("AccountObservers", observersSet)]
        
        create this with optNftAccount = Some (accountFactoryCid, holdingFactoryCid, instrumentFactoryCid, accountKey)

    nonconsuming choice Split : (ContractId Fungible.I, Optional (ContractId Fungible.I))
      with
        holdingCid : ContractId Holding.I
        amount: Decimal
      controller owner
      do
        holding <- fetch holdingCid
        assertMsg "Balance insufficient" (amount <= getAmount holding)
        let
          fungibleCid : ContractId Fungible.I = coerceContractId holdingCid
        Fungible.SplitResult{splitCids,rest} <- exercise fungibleCid Fungible.Split with amounts = [amount]
        pure (head (splitCids), rest)

-- we use custodian Party as admin for simplicity
data AccountType 
  = Admin 
  | Retail 
  | Pro 
  deriving (Eq, Show)
    